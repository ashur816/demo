对于同步，在具体的Java代码中需要完成一下两个操作：
把竞争访问的资源标识为private;
同步哪些修改变量的代码，使用synchronized关键字同步方法或代码，当然这不是唯一控制并发安全的途径。

1.同步方法
  即有synchronized关键字修饰的方法。

2.同步代码块
  即有synchronized关键字修饰的语句块。

3.使用特殊域变量(volatile)实现线程同步
    a.volatile关键字为域变量的访问提供了一种免锁机制，
    b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，
    c.因此每次使用该域就要重新计算，而不是使用寄存器中的值
    d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量

4.使用重入锁实现线程同步
    在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。
    ReentrantLock类是可重入、互斥、实现了Lock接口的锁，
    它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力
    ReentrantLock类的常用方法有：
            ReentrantLock() : 创建一个ReentrantLock实例
            lock() : 获得锁
            unlock() : 释放锁
        注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用

5.使用局部变量实现线程同步
    如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，
    副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。

锁机制实现了数据共享，本地变量实现的则是数据隔离

6.Atomic开头的类，都是原子操作，基于底层的地址偏移量，来实现的

7.ConcurrentHashMap本身是线程安全的，桶加锁

8.CopyOnWriteArrayList add(修改等)的时候ReentrantLock锁住，然后先Arrays.copyOf复制原有数据到newList，并且length+1，把值加入到newList，再将原容器的引用指向新的容器，
这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器
CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。
这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。
读写锁，可以同时获得多个读锁，只能有一个写锁，读的时候不能写，写的时候不能读